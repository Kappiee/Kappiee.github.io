# 函数

## 参数默认值

### 语法

在书写形参时，直接给形参赋值，附的值即为默认值

```js
function sum(a, b = 1, c = 2) {
    return a + b + c;
}

sum
```

这样一来，当调用函数时，如果没有给对应的参数赋值（给它的值是undefined），则会自动使用默认值。

### 示例

```js
function sum(a, b = 1, c = 2) {
    return a + b + c;
}

console.log(sum(10, undefined, undefined)) //13
console.log(sum(11)) //14
console.log(sum(1, undefined, 5)) //7
console.log(sum(1, null, 5)) //6  在js中null运算时算作0，不触发默认值
```

### 细节

#### 对arguments的影响

只要给函数加上参数默认值，该函数会自动变量严格模式下的规则：arguments和形参脱离。**后续改为使用`剩余参数`的形式来代替使用arguments**

```js
function test(a, b = 1) {
    console.log("arugments", arguments[0], arguments[1]); //1,2
    console.log("a:", a, "b:", b);//1,2
    a = 3;
    console.log("arugments", arguments[0], arguments[1]);//1,2
    console.log("a:", a, "b:", b);//3,2 arguments和形参脱离
}

test(1, 2);
```

#### 留意暂时性死区

形参和ES6中的let或const声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。

```js
function test(a = b, b) {
    console.log(a, b);
}

test(undefined, 2); // 报错 未声明b，原因是函数中会顺序声明形参并且使用块级作用域
```

```js
function test(a, b = a) {
    console.log(a, b);
}

test(2); //2 2 正常
```

## 剩余参数 ...args

arguments的缺陷：

1. 如果和形参配合使用，容易导致混乱
2. 从语义上，使用arguments获取参数，由于形参缺失，无法从函数定义上理解函数的真实意图

```js
function test(a, b = 1) {
    console.log("arugments", arguments[0], arguments[1]); //1,2
    console.log("a:", a, "b:", b);//1,2
    a = 3;
    console.log("arugments", arguments[0], arguments[1]);//1,2
    console.log("a:", a, "b:", b);//3,2 arguments和形参脱离
}

test
```

ES6的剩余参数专门用于手机末尾的所有参数，将其放置到一个形参数组中。

### 语法

```js
function xx (...形参名){
    形参名
}

xx
```

### 示例

```js
function sum(...args) {
    //args收集了所有的参数，形成的一个数组
    let sum = 0;
    for (let i = 0; i < args.length; i++) {
        sum += args[i];
    }
    return sum;
}

console.log(sum())
console.log(sum(1))
console.log(sum(1, 2))
console.log(sum(1, 2, 3))
console.log(sum(1, 2, 3, 4))
```

### 细节

1. 一个函数，仅能出现一个剩余参数
2. 一个函数，如果有剩余参数，剩余参数必须是最后一个参数
